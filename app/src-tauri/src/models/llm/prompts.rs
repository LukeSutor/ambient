use once_cell::sync::Lazy;
use std::collections::HashMap;

// Use Lazy to initialize the HashMap only once
static PROMPTS: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
  let mut map = HashMap::new();
  map.insert(
  "summarize_screen",
r#"You are a screen activity summarization expert. You will be given the previous summary generated by this service, and text captured from a user's screen and need to generate a concise 2-3 sentence summary of what the user is actively doing.

Output JSON format:
{"summary":"<2-3 sentence summary of current user activity>"}

Rules:
- Keep summary to exactly 1-2 sentences maximum
- Focus on the primary activity the user is engaged in
- Include specific application names and context when relevant
- Mention URLs/websites for web browsing activities
- Be specific about what type of work/task is being performed
- Focus on the current activity and simply use the previous summary as context
- Use present tense and active voice

<previous_summary>
{previous_summary}
</previous_summary>

<screen_text>
{text}
</screen_text>

<active_url>
{active_url}
</active_url>

Generate a concise summary that captures the user's current primary activity in 1-2 sentences."#,
);
  map.insert(
    "detect_tasks",
r#"You are a task detection expert. You will be given a summary of the user's previous screen state and the new text that has appeared on their screen since the last check. Based on these changes and the context from the previous summary, determine which task steps have been completed.

Output JSON format:
{"analysis":"<reasoning for why steps are completed>","completed":[<completed step IDs>]}

Rules:
- Make sure your reasoning is clear and concise, 2 sentences maximum.
- Make sure your reasoning is relevant to task completion, not just a summary of the text.
- Ensure to only include step IDs that are present in the list of tasks provided
- Do not include a step in the completed array if it is already marked complete
- If there are no completed steps, return an empty array
- Focus on what the NEW text indicates about task completion, using the previous summary for context

<tasks>
{tasks}
</tasks>

<previous_summary>
{previous_summary}
</previous_summary>

<new_screen_text>
{text}
</new_screen_text>

<active_url>
{active_url}
</active_url>

IMPORTANT: Only mark steps complete if the NEW screen text shows clear evidence of completion. Use the previous summary to understand what the user was doing before, then analyze what the new text indicates about their progress.
Use your reasoning extremely concisely, focusing on the specific steps are are completed rather than summarizing the entire screen text.
You are analyzing CHANGES in the user's screen, not the full screen state. The previous summary tells you what they were doing before, and the new screen text shows what has changed or appeared since then.
"#,
      );
  map
});

/// Fetches a prompt by its key.
pub fn get_prompt(key: &str) -> Option<&'static str> {
  PROMPTS.get(key).copied()
}

/// Tauri command to fetch a prompt by its key.
#[tauri::command]
pub fn get_prompt_command(key: String) -> Result<String, String> {
  match get_prompt(&key) {
    Some(prompt) => Ok(prompt.to_string()),
    None => Err(format!("Prompt with key '{}' not found.", key)),
  }
}
