use once_cell::sync::Lazy;
use std::collections::HashMap;

// Use Lazy to initialize the HashMap only once
static PROMPTS: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
  let mut map = HashMap::new();
  map.insert(
  "summarize_screen",
r#"You are a screen activity summarization expert. You will be given the previous summary generated by this service, and text captured from a user's screen and need to generate a concise 2-3 sentence summary of what the user is actively doing.

Output JSON format:
{"summary":"<2-3 sentence summary of current user activity>"}

Rules:
- Keep summary to exactly 1-2 sentences maximum
- Focus on the primary activity the user is engaged in
- Include specific application names and context when relevant
- Mention URLs/websites for web browsing activities
- Be specific about what type of work/task is being performed
- Focus on the current activity and simply use the previous summary as context
- Use present tense and active voice

<previous_summary>
{previous_summary}
</previous_summary>

<screen_text>
{text}
</screen_text>

<active_url>
{active_url}
</active_url>

Generate a concise summary that captures the user's current primary activity in 1-2 sentences."#,
);
  map.insert(
    "detect_tasks",
    r#"TASK: Detect which steps completed based on screen changes.

OUTPUT: {"analysis":"<why step completed>","completed":[<step IDs>]}

<previous_summary>
{previous_summary}
</previous_summary>

<new_screen_text>
{text}
</new_screen_text>

URL: {active_url}

<tasks>
{tasks}
</tasks>

KEY RULE: Analysis must explain WHY a step is done, NOT summarize screen.

ANALYZE THE CHANGES:
1. Previous summary = what user WAS doing
2. New text = what CHANGED on screen
3. Your job = identify COMPLETED steps from changes

CRITICAL RULES:
- Only mark step complete if NEW text proves completion
- Analysis = reasoning about task completion (not screen summary!)
- Skip already-complete steps
- Empty array if nothing new completed
- Max 2 sentences reasoning

REMEMBER: {"analysis":"<why step completed>","completed":[<step IDs>]}
Focus on TASK COMPLETION evidence, not general screen activity. Maximum 2 sentences analysis."#,
  );
  map.insert(
    "extract_interactive_memory",
    r#"Extract important facts about the user. Return empty string if nothing important.

{"memory":"<fact about user or empty string>"}

Only extract:
- Personal facts (has pets, job, hobbies)
- Preferences (likes/dislikes)
- Goals or projects

Do NOT extract:
- Questions
- Greetings like "hello"
- Requests for help

Examples:
User: "Hi there" → {"memory":""}
User: "What's the weather?" → {"memory":""}
User: "I have a dog named Max" → {"memory":"User has a dog named Max"}
User: "I'm studying Spanish" → {"memory":"User is learning Spanish"}
User: "Can you help me code?" → {"memory":""}"#,
  );
  map.insert(
    "generate_conversation_name",
    r#"Generate a 2-5 word title for this conversation based on the user's message.

{"name":"<short title>"}

Rules:
- Use 2-5 words maximum
- Capture the main topic/intent
- No punctuation or quotes
- Be specific, not generic

Examples:
"How do I sort a list in Python?" → {"name":"Python List Sorting"}
"What's the capital of France?" → {"name":"France Capital Question"}
"Help me write a resume" → {"name":"Resume Writing Help"}"#,
  );
  map.insert(
    "hud_chat",
    r#"You are Ambient, a helpful AI assistant. Today is {currentDateTime}.

You may receive:
- Memories: Past facts about the user
- Images: Screenshots or photos provided by the user
- OCR: Text from user's screen
- PDFs: Documents provided by the user
- Task: The user's current request

Be helpful and use the memories and OCR when relevant. Use markdown for formatting. You are responding directly to the user."#,
  );
  map.insert(
    "agentic_chat",
    r#"You are Ambient, a helpful AI assistant. Today is {date}.

{skills_section}

## Skill Activation
When you need capabilities from a skill:
1. Call the `activate_skill` function with the skill name
2. After activation, the skill's tools will become available
3. Use the tools to complete the user's request

## Guidelines
- Only activate skills when necessary for the task
- Provide clear, helpful responses"#,
  );
  map
});

/// Fetches a prompt by its key.
pub fn get_prompt(key: &str) -> Option<&'static str> {
  PROMPTS.get(key).copied()
}

/// Tauri command to fetch a prompt by its key.
#[tauri::command]
pub fn get_prompt_command(key: String) -> Result<String, String> {
  match get_prompt(&key) {
    Some(prompt) => Ok(prompt.to_string()),
    None => Err(format!("Prompt with key '{}' not found.", key)),
  }
}
